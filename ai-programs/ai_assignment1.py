# -*- coding: utf-8 -*-
"""Copy of G24AIT2008_AI_Assignment1.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13mVjau4JsyxoYIRndooO5XLfJjlI3L1F
"""

import random
import numpy as np

# Set random seed for reproducibility
random.seed(42)

# Parameters
N = random.randint(5, 10)  # Warehouse rows
M = random.randint(5, 10)  # Warehouse columns
P = random.randint(2, 6)   # Number of packages
O = random.randint(1, 10)  # Number of obstacles

# Initialize warehouse grid
warehouse = np.full((N, M), ' ')  # Empty grid

# Place packages and drop-off points
package_locations = []
dropoff_locations = []
while len(package_locations) < P:
    x, y = random.randint(0, N-1), random.randint(0, M-1)
    if warehouse[x, y] == ' ':  # Ensure no overlap
        warehouse[x, y] = 'P'  # Mark package
        package_locations.append((x, y))

while len(dropoff_locations) < P:
    x, y = random.randint(0, N-1), random.randint(0, M-1)
    if warehouse[x, y] == ' ':  # Ensure no overlap
        warehouse[x, y] = 'D'  # Mark drop-off point
        dropoff_locations.append((x, y))

# Place obstacles
obstacle_locations = []
while len(obstacle_locations) < O:
    x, y = random.randint(0, N-1), random.randint(0, M-1)
    if warehouse[x, y] == ' ':  # Ensure no overlap
        warehouse[x, y] = 'O'  # Mark obstacle
        obstacle_locations.append((x, y))

# Define robot starting position
while True:
    Sx, Sy = random.randint(0, N-1), random.randint(0, M-1)
    if warehouse[Sx, Sy] == ' ':  # Ensure no overlap
        warehouse[Sx, Sy] = 'R'  # Mark robot
        robot_start = (Sx, Sy)
        break

# Display initial warehouse configuration
print("Warehouse Configuration:")
print(warehouse)
print("Package Locations:", package_locations)
print("Drop-off Locations:", dropoff_locations)
print("Obstacle Locations:", obstacle_locations)
print("Robot Start Position:", robot_start)

from collections import deque

def bfs(warehouse, start, goal):
    """Breadth-First Search to find the shortest path."""
    rows, cols = warehouse.shape
    queue = deque([(start, [start])])
    visited = set()

    while queue:
        (x, y), path = queue.popleft()

        if (x, y) == goal:
            return path

        if (x, y) in visited:
            continue

        visited.add((x, y))

        # Explore neighbors
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < rows and 0 <= ny < cols and warehouse[nx, ny] != 'O':
                queue.append(((nx, ny), path + [(nx, ny)]))

    return None  # No path found

# Initialize variables
current_position = robot_start
total_cost = 0
total_reward = 0
final_path = []

# Deliver packages
for package, dropoff in zip(package_locations, dropoff_locations):
    # Path to package
    path_to_package = bfs(warehouse, current_position, package)
    if path_to_package:
        total_cost += len(path_to_package) - 1
        final_path.extend(path_to_package[1:])
        current_position = package

    # Path to drop-off
    path_to_dropoff = bfs(warehouse, current_position, dropoff)
    if path_to_dropoff:
        total_cost += len(path_to_dropoff) - 1
        total_reward += 10  # Delivery reward
        final_path.extend(path_to_dropoff[1:])
        current_position = dropoff

# Results
print("Final Path:", final_path)
print("Total Cost:", total_cost)
print("Total Reward:", total_reward)

# Calculate final score
obstacle_penalty = 0  # No obstacles hit in this simulation
final_score = total_reward - total_cost + obstacle_penalty

# Output results
print("Final Score:", final_score)